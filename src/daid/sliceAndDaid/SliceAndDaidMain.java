package daid.sliceAndDaid;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Vector;

import javax.swing.SwingUtilities;

import daid.sliceAndDaid.config.CraftConfig;
import daid.sliceAndDaid.config.CraftConfigLoader;
import daid.sliceAndDaid.tool.GCodeTool;
import daid.sliceAndDaid.tool.PerimeterTool;
import daid.sliceAndDaid.tool.PathTool;
import daid.sliceAndDaid.tool.SliceTool;
import daid.sliceAndDaid.tool.SpeedTool;
import daid.sliceAndDaid.ui.ConfigWindow;
import daid.sliceAndDaid.ui.PreviewFrame;
import daid.sliceAndDaid.util.GCodeFile;
import daid.sliceAndDaid.util.Logger;
import daid.sliceAndDaid.util.Vector2;

public class SliceAndDaidMain
{
    public static void main(String[] args)
    {
        Logger.setLevel(Logger.LOG_LEVEL_MESSAGE);
        CraftConfigLoader.loadConfig(null);

        if (args.length < 1)
        {

            SwingUtilities.invokeLater(new Runnable()
            {
                public void run()
                {
                    try
                    {
                        new ConfigWindow();
                    } catch (Exception e)
                    {
                        // We sometimes get a "Cannot write XdndAware property" exception in Java
                        // 1.6.0_22 in Linux. Seems to be a java bug related to the text areas.

                        // Just retry and hope for the best.
                        if (e.getMessage().equals("Cannot write XdndAware property"))
                        {
                            new ConfigWindow();
                            return;
                        }
                        e.printStackTrace();
                        System.exit(-1);
                    }
                }
            });
        } else
        {
            for (int i = 0; i < args.length; i++)
                sliceModel(args[i]);
        }
    }

    public static void sliceModel(String filename)
    {
        long startTime = System.currentTimeMillis();
        CraftConfig.lastSlicedFile = filename;
        CraftConfigLoader.saveConfig(null);

        Model m;
        try
        {
            m = new Model(filename);
        } catch (IOException e)
        {
            e.printStackTrace();
            Logger.error("Failed to load model");
            return;
        }
        m.center();
        SliceTool slicer = new SliceTool(m);
        final Vector<Layer> layers = slicer.sliceModel(CraftConfig.startLayerNr, CraftConfig.endLayerNr, 0.0);
        Logger.updateStatus("Creating skirt");
        if (CraftConfig.skirtDistance > 0)
        {
            layers.get(0).skirt = new PerimeterTool(layers.get(0).modelPart, -CraftConfig.skirtDistance).createPerimeter().makeConvex();
        }
        Logger.updateStatus("Creating outlines");
        for (int i = 0; i < layers.size(); i++)
        {
            Logger.setProgress(i, layers.size());
            LayerPart prevPart = layers.get(i).modelPart;
            for (int c = 0; c < CraftConfig.perimeterCount; c++)
            {
                if (c == 0)
                    prevPart = new PerimeterTool(prevPart, CraftConfig.perimeterWidth * 0.5).createPerimeter();
                else
                    prevPart = new PerimeterTool(prevPart, CraftConfig.perimeterWidth).createPerimeter();
                layers.get(i).outlinePart[c] = prevPart;
            }
        }
        Logger.updateStatus("Generating paths");
        Vector2 startPoint = new Vector2(0, 0);
        for (int i = 0; i < layers.size(); i++)
        {
            Logger.setProgress(i, layers.size());
            new PathTool(layers.get(i)).generatePath(startPoint);
            if (layers.get(i).pathStart != null)
                startPoint = layers.get(i).pathStart.start;
        }
        Logger.updateStatus("Setting speeds");
        for (int i = 0; i < layers.size(); i++)
        {
            Logger.setProgress(i, layers.size());
            new SpeedTool(layers.get(i)).updateSpeed();
        }
        Logger.updateStatus("Generating GCode");
        try
        {
            GCodeFile gcodeFile = new GCodeFile(new FileWriter(filename + "_export.gcode"));
            gcodeFile.writeComment("GCode generated by SliceAndDaid:" + CraftConfig.VERSION);

            for (String line : CraftConfig.startGCode.split("\n"))
                gcodeFile.write(line);
            // gcodeFile.write("M101; extruder on (to get skeinlayer working)");

            for (int i = 0; i < layers.size(); i++)
            {
                Logger.setProgress(i, layers.size());
                new GCodeTool(layers.get(i), gcodeFile).generateGCode();
            }

            // gcodeFile.write("M103; extruder off (to get skeinlayer working)");
            for (String line : CraftConfig.endGCode.split("\n"))
                gcodeFile.write(line);
            gcodeFile.close();
            Logger.message("Expected print time: " + ((int) gcodeFile.getBuildTime() / 60) + " minutes");
        } catch (IOException e)
        {
            e.printStackTrace();
        }

        /* Post slicing */
        long sliceTime = System.currentTimeMillis() - startTime;
        Logger.message("Slice time: " + (((double) sliceTime) / 1000) + " seconds");
        SwingUtilities.invokeLater(new Runnable()
        {
            public void run()
            {
                new PreviewFrame(layers);
            }
        });
    }
}
